# Hooks

One day, our Peter the Project Manager comes to us with a great idea to improve the app. He suggests we wish our users a happy day as a part of the greeting message (a bit of kindness goes a long way). That sounds easy enough, and so we change the `greet()` function to reflect that suggestion:

<CodeFile file="greet.js" range="1-5" highlight="4" />

Since the intention behind the code has changed (now it also includes the day of the week), we should adjust the relevant tests to capture that:

<CodeFile file="greet.test.js" range="1-5" highlight="4" />

The issue with this test is that it will only pass on Mondays! That won't do. We need a _deterministic_ test, no matter where or when we run it. To fix this, let's first understand why this happens.

Our `greet()` function constructs a `Date` to extract a weekday from it. This is a perfectly valid logic but it's also a _side effect_. The values that `Date` returns are not predictable‚Äîthey change based on, well, the current date! We need to account for that change in our test by, somehow, _freezing_ the current date and making it return the same value on every test run.

> The usage of `Date` in this case is just an example of a side effect your code may introduce. Whatever it is, the handling of such side effects is often the same.

To handle side effects such as this one, tests often have the concept of "hooks". Hooks are functions that allow you to execute arbitrary code before, during, and after the test run. The purpose of hooks is to help you prepare the environment that runs your tested code.

üë®‚Äçüíº In this exercise, you'd have to implement _two_ new global functions (hooks) in `setup.js`:

- `beforeAll()`, which accepts a callback argument and runs it before all tests;
- `afterAll()`, which accepts a callback argument and runs it after the tests are done.

<callout-info>You can treat the process `exit` event as the indicator that all tests are done.</callout-info>

Once you do, add a `beforeAll()` hook to the `greet.test.js` to patch the `globalThis.Date` constructor and return a fixed date from it. Make sure to undo the patch after the tests to keep the test environment clean. And, of course, make sure the tests are passing.

Feel free to use the following snippet to mock the `Date` constructor:

```js nocopy
const DateProxy = Proxy.revocable(globalThis.Date, {
	construct: Date => new Date('2024-01-01'),
})

beforeAll(() => {
	globalThis.Date = DateProxy.proxy
})

afterAll(() => {
	DateProxy.revoke()
})
```

---

## INTERNAL NOTES

<callout-success class="important">A good test only fails when the intention behind the system is breached.</callout-success>

- HTTP request.
- Connecting to a datbase.
- Relying on globals.
- **Timers**.

```

```
