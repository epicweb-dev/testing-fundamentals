# Intentions

<EpicVideo url="https://www.epicweb.dev/workshops/testing-fundamentals/principles/write-an-intentional-test/solution" />

To get started, I will call the `greet` function with the name `"John"` and store the result in a new variable called `message`.

```ts filename=greet.ts nonumber
let message = greet('John')
```

With this argument, I expect the `greet` function to return a `"Hello, John!"` string. I will compare the actual `message` it returns with the expected (intended) message, and if they don't match, throw an error that lets me know something is off with the function.

```ts filename=greet.ts highlight=2-4 nonumber
if (message !== 'Hello, John!') {
	throw new Error(
		`Expected message to equal to "Hello, John!" but got "${message}"`,
	)
}
```

:tada: Congratulations! You've just written the most basic automated test.

Now, on its own, just _having_ a test doesn't bring us any value. We need to _run_ it. At this stage, we can do that by running the `greet.ts` file using Node.js:

```sh nonumber
npx tsx greet.ts
```

It may seem like nothing is happening but that's not true. Our file and our test are run and Node.js exits without errors, which means that our `greet` function works as intended.

As counter-intuitive as it may sound, you get the most value out of tests not when they pass but when they _fail_. Let's take a look at test failures in the next exercise.

ðŸ¦‰ Intention plays a crucial rule in [The True Purpose of Testing](https://www.epicweb.dev/the-true-purpose-of-testing).
